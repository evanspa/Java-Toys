package unittest.spring_configuration;



import name.paulevans.testutils.XMLTestUtils;
import name.paulevans.utils.XMLUtils;
import net.javacrumbs.springws.test.context.WsTestContextHolder;
import net.javacrumbs.springws.test.helper.WsTestHelper;

import org.custommonkey.xmlunit.XMLAssert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.ws.context.MessageContext;

/**
 * <p>Test to ensure that our client Spring configuration is wired and
 * configured properly</p>
 * 
 * <p>We're going to be testing that request XML payloads are being created
 * properly from both a content and schema-validation perspective.</p>
 * 
 * <p>On the response side, we're going to make sure that pre-configured,
 * canned response XML payloads will be unmarshaled properly</p>
 * 
 * @author Paul R Evans
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"classpath:spring-ws-servlet.xml",
		"classpath:alternative-helper-config.xml"})
public class TestSpringServerConfig {
	
	static {
		XMLTestUtils.createNSMappingsForXMLUnitRuntime();
	}

    /**
     * Spring-WS-test helper instance
     */
	@Autowired private WsTestHelper wsTestHelper;
	
	/**
	 * <p>Test to ensure the response generated by our Spring web service
	 * configuration is valid for various combinations of valid request
	 * scenarios.</p>   
	 */
	@Test public void testValidRequest() {
		
		// assert the expected 2-char prefix on the response's identifier value
		// when using a valid combination of use case and channel values... 
		assertValidRequest("Place Order", "Web", "PW", wsTestHelper);
		
		// and another...
		assertValidRequest("Place Order", "Call Center", "PC", wsTestHelper);
		
		// and another...
		assertValidRequest("Calculate Order Sub-total", "IVR", "CI", 
				wsTestHelper);
	}
	
	/**
	 * <p>Test to ensure the response generated by our Spring web service
	 * configuration is indeed a client SOAP fault (due to the generated request
	 * having a correct structure, but with invalid content).</p>
	 */
	@Test public void testInvalidRequestContent() {
		
		// assert SOAP client fault for invalid use case value...
		assertInvalidRequest("PlaceOrder", "Web", 
				"simulatedRequest_validStructure_template.xml", wsTestHelper);
		
		// assert SOAP client fault for invalid channel value...
		assertInvalidRequest("Place Order", "Webbb", 
				"simulatedRequest_validStructure_template.xml", wsTestHelper);
		
		// now try with an empty use case...
		assertInvalidRequest("", "IVR", 
				"simulatedRequest_validStructure_template.xml", wsTestHelper);
		
		// now try with an empty channel...
		assertInvalidRequest("Load Catalog", "", 
				"simulatedRequest_validStructure_template.xml", wsTestHelper);
		
		// now try with both of 'em empty...
		assertInvalidRequest("", "",
				"simulatedRequest_validStructure_template.xml", wsTestHelper);
	}
	
	/**
	 * <p>Test to ensure the response generated by our Spring web service
	 * configuration is indeed a client SOAP fault - only this time to cause
	 * of the fault is that the structure of the request is invalid relative
	 * to our 'commands' schema</p>
	 */
	@Test public void testInvalidRequestStructure() {
		
		// assert SOAP client fault when using valid use case and channel
		// values (the fault is because of a schema validation due to the
		// structure of the request being invalid...
		assertInvalidRequest("Place Order", "Web", 
				"simulatedRequest_invalidStructure_template.xml", wsTestHelper);
		
		// and another...
		assertInvalidRequest("Load Catalog", "IVR", 
				"simulatedRequest_invalidStructure_template.xml", wsTestHelper);
	}

	/**
	 * <p>A convenience method that asserts that the first 2 characters of
	 * the identifier value contained in the response generated by our web
	 * service configuration is equal to the supplied 'expected request'
	 * value; the response generated is based on a request that will be
	 * generated based on the supplied use case and channel values.</p>
	 * 
	 * @param pUseCase the use cause value to be placed within the simulated
	 * request
	 * @param pChannel the channel value to be placed within the simulated
	 * request
	 * @param pExpectedPrefix the expected 2-character prefix of the identifier
	 * value of the generated response
	 * @param pWsTestHelper the Spring-WS-test helper instance that is used
	 * to created the simulated request and assembles our Spring web service
	 * configuration such that a response can be created
	 */
	private static void assertValidRequest(String pUseCase, String pChannel,
			String pExpectedPrefix, WsTestHelper pWsTestHelper) {
		
		MessageContext message;
		String responsePayloadAsStr;
		
		try {
		
			WsTestContextHolder.getTestContext().setAttribute("usecase", 
					pUseCase);
			WsTestContextHolder.getTestContext().setAttribute("channel", 
					pChannel);
			
			// simulates request coming to MessageDispatcherServlet
	        message = pWsTestHelper.receiveMessage(
	        		"simulatedRequest_validStructure_template.xml");	
	        
	        // get the response payload as a string...
	        responsePayloadAsStr = XMLUtils.toString(message.getResponse().
	        		getPayloadSource());
       
	        // validate the response and assert it is not a fault...
	        pWsTestHelper.createMessageValidator(message.getResponse()).
	        	assertNotSoapFault().validate("TransactionIdentifier-types.xsd");
	        
	        // assert the first 2 chars of the identifier value in the response
	        // is correct...
	        XMLAssert.assertXpathEvaluatesTo(pExpectedPrefix, 
	        	"substring(/TxnIDTypes:TransactionIdentifier/@identifierValue,1,2)", 
	        	responsePayloadAsStr);  
		} catch (Exception any) {
			throw new RuntimeException(any);
		}
	}
	
	/**
	 * <p>Convenience method to assert the supplied use case and channel values,
	 * when used to construct a request, will result in a SOAP client fault
	 * being produced for the response.</p>
	 * 
	 * <p>Generally speaking, there are 2 possible XML templates that can be
	 * used: simulatedRequest_invalidStructure_template.xml and
	 * simulatedRequest_validStructure_template.xml.  The first one is used to
	 * purposely generate a request that *should* result in a schema validation
	 * error, and thus a SOAP client fault.  The second one is used to 
	 * generate a request that will be schema-valid from a structural standpoint,
	 * but whose values will not be valid, and thus *should* result in a 
	 * schema validation error and thus a SOAP client fault.
	 * 
	 * @param pUseCase use case value to be used when constructing the
	 * simulated request
	 * @param pChannel channel value to be used when constructing the 
	 * simulated request
	 * @param pSimulatedRequestXmlTemplate the name of the XML template file
	 * name to use to generate the simulated request
	 * @param pWsTestHelper Spring-WS-test web service test helper instance
	 */
	private static void assertInvalidRequest(String pUseCase, 
			String pChannel, String pSimulatedRequestXmlTemplate,
			WsTestHelper pWsTestHelper) {
		
		MessageContext message;
		
		try {
		
			WsTestContextHolder.getTestContext().setAttribute("usecase", 
					pUseCase);
			WsTestContextHolder.getTestContext().setAttribute("channel", 
					pChannel);
			
			// simulates request coming to MessageDispatcherServlet
	        message = pWsTestHelper.receiveMessage(
	        		pSimulatedRequestXmlTemplate);	
	        
	        System.out.println(XMLUtils.toString(message.getResponse().
	        		getPayloadSource()));
       
	        // validate the response is in fact a fault...
	        pWsTestHelper.createMessageValidator(message.getResponse()).
	        	assertSoapFault().assertFaultCode("Client");
 
		} catch (Exception any) {
			throw new RuntimeException(any);
		}
	}
}
